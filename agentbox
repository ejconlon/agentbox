#!/usr/bin/env bash
# AgentBox - Simplified Docker environment for Claude/Codex development
# Automatically rebuilds when Dockerfile changes and uses ephemeral containers with persistent caches

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="/opt/agentbox"
readonly PROJECT_DIR="$(pwd)"
readonly PROJECT_NAME="$(basename "$PROJECT_DIR")"
readonly DOCKERFILE_PATH="${SCRIPT_DIR}/Dockerfile"
readonly ENTRYPOINT_PATH="${SCRIPT_DIR}/entrypoint"
readonly IMAGE_NAME="agentbox:latest"
readonly CONTAINER_PREFIX="agentbox"
readonly USERNAME="agentbox"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Helper functions
log_info() { echo -e "${BLUE}ℹ${NC}  $1"; }
log_success() { echo -e "${GREEN}✅${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC}  $1"; }
log_error() { echo -e "${RED}❌${NC} $1" >&2; }
log_build() { echo -e "${CYAN}🔨${NC} $1"; }

# Check if Docker is installed and running
check_docker() {
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed. Please install Docker first."
        exit 1
    fi

    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running. Please start Docker."
        exit 1
    fi
}

# Calculate hash for a file
calculate_hash() {
    local file="$1"
    if [[ -f "$file" ]]; then
        sha256sum "$file" | cut -d' ' -f1
    else
        echo "none"
    fi
}

# Get container name for current project
get_container_name() {
    local project_hash=$(echo -n "$PROJECT_DIR" | sha256sum | cut -c1-12)
    echo "${CONTAINER_PREFIX}-${project_hash}"
}


# Check if image needs rebuild
needs_rebuild() {
    # Calculate current Dockerfile and entrypoint hashes
    local dockerfile_hash=$(calculate_hash "$DOCKERFILE_PATH")
    local entrypoint_hash=$(calculate_hash "$ENTRYPOINT_PATH")
    local combined_hash="${dockerfile_hash}-${entrypoint_hash}"

    # Check if image exists
    if ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
        return 0  # Needs rebuild - image doesn't exist
    fi

    # Get stored hash from image
    local stored_hash=$(docker inspect "$IMAGE_NAME" \
        --format '{{ index .Config.Labels "agentbox.hash" }}' 2>/dev/null || echo "none")

    # Compare hashes
    if [[ "$combined_hash" != "$stored_hash" ]]; then
        return 0  # Needs rebuild
    fi

    return 1  # No rebuild needed
}

# Build Docker image
build_image() {
    local dockerfile_hash=$(calculate_hash "$DOCKERFILE_PATH")
    local entrypoint_hash=$(calculate_hash "$ENTRYPOINT_PATH")
    local combined_hash="${dockerfile_hash}-${entrypoint_hash}"

    log_build "Building AgentBox image (this may take a few minutes on first run)..."

    # Get current user/group IDs
    local user_id=$(id -u)
    local group_id=$(id -g)

    # Build with progress output
    if docker build \
        --build-arg USER_ID="${user_id}" \
        --build-arg GROUP_ID="${group_id}" \
        --build-arg USERNAME="${USERNAME}" \
        --label "agentbox.hash=${combined_hash}" \
        --label "agentbox.version=1.0.0" \
        --label "agentbox.built=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        -t "$IMAGE_NAME" \
        "$SCRIPT_DIR" ; then
        log_success "Image built successfully!"
        return 0
    else
        log_error "Failed to build image"
        return 1
    fi
}

# Cleanup old containers using outdated image
cleanup_old_containers() {
    log_info "Checking for containers using outdated image..."

    # Get the current image ID
    local current_image_id=$(docker inspect "$IMAGE_NAME" --format '{{ .Id }}' 2>/dev/null || echo "none")

    if [[ "$current_image_id" == "none" ]]; then
        return
    fi

    # Find all agentbox containers
    local containers=$(docker ps -a --format '{{.Names}}' | grep "^${CONTAINER_PREFIX}-" || true)

    if [[ -z "$containers" ]]; then
        return
    fi

    local cleaned_count=0

    for container in $containers; do
        local container_image_id=$(docker inspect "$container" --format '{{ .Image }}' 2>/dev/null || echo "none")

        if [[ "$container_image_id" != "$current_image_id" ]]; then
            log_warning "Removing outdated container: $container"
            docker rm -f "$container" &> /dev/null || true
            ((cleaned_count++))
        fi
    done

    if [[ $cleaned_count -gt 0 ]]; then
        log_success "Cleaned up $cleaned_count outdated container(s)"
    fi
}

# Run container with --rm (ephemeral)
run_container() {
    local container_name="$1"
    shift
    local mode="$1"
    shift
    local cmd_args=("$@")

    if [[ "$mode" == "admin" ]]; then
        log_success "Starting container for: $PROJECT_NAME (admin shell)"
    else
        log_success "Starting container for: $PROJECT_NAME"
    fi

    # Prepare mount options
    local mount_opts=(
        -v "$PROJECT_DIR:/workspace:z"
    )

    # Mount .gitconfig if it exists
    if [[ -f "${HOME}/.gitconfig" ]]; then
        mount_opts+=(-v "${HOME}/.gitconfig:/home/${USERNAME}/.gitconfig:ro")
    fi

    if [[ "$mode" == "claude" ]]; then
      # Use Docker named volume for Claude config
      local claude_volume_name="agentbox-claude-${container_name#agentbox-}"

      # Check if volume exists and initialize if needed
      if ! docker volume inspect "$claude_volume_name" &>/dev/null; then
          log_info "Creating Claude CLI volume and copying authentication from global config"
          docker volume create "$claude_volume_name" &>/dev/null

          # Change permissions on volume
          docker run --rm \
            -v "${codex_volume_name}:/dest" \
            "$IMAGE_NAME" \
            bash -c 'sudo chown 1000:1000 /dest'

          # Initialize volume with global Claude config if it exists
          if [[ -d "${HOME}/.claude" ]]; then
              # Use a temporary container to copy data to the volume
              docker run --rm \
                  --user 1000:1000 \
                  -v "${HOME}/.claude:/source:ro" \
                  -v "${claude_volume_name}:/dest" \
                  "$IMAGE_NAME" \
                  sh -c "cp -r /source/* /dest/ 2>/dev/null || true"
          fi
      fi

      mount_opts+=(-v "${claude_volume_name}:/home/${USERNAME}/.claude")

      # Set Claude config directory environment variable
      mount_opts+=(--env "CLAUDE_CONFIG_DIR=/home/${USERNAME}/.claude")

      log_info "Claude CLI configuration mounted"
    fi

    if [[ "$mode" == "codex" ]]; then
      # Use Docker named volume for codex config
      local codex_volume_name="agentbox-codex-${container_name#agentbox-}"

      # Check if volume exists and initialize if needed
      if ! docker volume inspect "$codex_volume_name" &>/dev/null; then
          log_info "Creating codex CLI volume and copying authentication from global config"
          docker volume create "$codex_volume_name" &>/dev/null

          # Change permissions on volume
          docker run --rm \
            -v "${codex_volume_name}:/dest" \
            "$IMAGE_NAME" \
            sh -c 'sudo chown 1000:1000 /dest'

          # Initialize volume with global codex config if it exists
          if [[ -d "${HOME}/.codex" ]]; then
              # Use a temporary container to copy data to the volume
              docker run --rm \
                  --user 1000:1000 \
                  -v "${HOME}/.codex:/source:ro" \
                  -v "${codex_volume_name}:/dest" \
                  "$IMAGE_NAME" \
                  sh -c 'cp -r /source/* /dest/ || true'
          fi
      fi

      mount_opts+=(-v "${codex_volume_name}:/home/${USERNAME}/.codex")

      # Set codex config directory environment variable
      mount_opts+=(--env "CODEX_HOME=/home/${USERNAME}/.codex")

      log_info "codex CLI configuration mounted"
    fi

    # Prepare the command to run
    local container_cmd
    if [[ "$mode" == "shell" ]]; then
        container_cmd=("${cmd_args[@]:-/bin/bash}")
    elif [[ "$mode" == "admin" ]]; then
        container_cmd=(bash -c "echo '🔒 Admin shell - sudo access enabled' && exec ${cmd_args[*]:-/bin/bash}")
    elif [[ "$mode" == "claude" ]]; then
        # Run through bash to get proper environment
        # Always include YOLO, append any additional flags
        local claude_cmd="claude --dangerously-skip-permissions"
        if [[ ${#cmd_args[@]} -gt 0 ]]; then
            claude_cmd="$claude_cmd ${cmd_args[*]}"
        fi
        container_cmd=(bash -c "source ~/.bashrc && exec $claude_cmd")
    elif [[ "$mode" == "codex" ]]; then
        # Run through bash to get proper environment
        # Always include YOLO, append any additional flags
        local codex_cmd="codex --dangerously-bypass-approvals-and-sandbox"
        if [[ ${#cmd_args[@]} -gt 0 ]]; then
            codex_cmd="$codex_cmd ${cmd_args[*]}"
        fi
        container_cmd=(bash -c "source ~/.bashrc && exec $codex_cmd")
    else
        echo "Internal error - unsupported mode"
        exit 1
    fi

    # Check for .env file in project directory and add to docker args
    local env_file_args=()
    if [[ -f "$PROJECT_DIR/.env" ]]; then
        env_file_args+=(--env-file "$PROJECT_DIR/.env")
        log_info ".env file found and will be loaded into container"
    fi

    # Run ephemeral container with --rm
    docker run -it --rm \
        --user 1000:1000 \
        --name "$container_name" \
        --hostname "agentbox-$PROJECT_NAME" \
        --env "VIRTUAL_ENV=/workspace/.agentbox/venv" \
        --env "UV_PROJECT_ENVIRONMENT=/workspace/.agentbox/venv" \
        --env "UV_CACHE_DIR=/workspace/.agentbox/cache" \
        --env "UV_PYTHON_CACHE_DIR=/workspace/.agentbox/pycache" \
        --env "UV_PYTHON_INSTALL_DIR=/workspace/.agentbox/pyinst" \
        --env "UV_TOOL_DIR=/workspace/.agentbox/pytool" \
        "${mount_opts[@]}" \
        "${env_file_args[@]}" \
        -w /workspace \
        --init \
        "$IMAGE_NAME" \
        "${container_cmd[@]}"
}

# Show help
show_help() {
    cat << EOF
AgentBox - Simplified Docker environment for Claude development

Usage:
    agentbox [COMMAND] [ARGS]

Commands:
    -h, --help  Show this help message
    build       Force rebuild of the image
    clean       Remove AgentBox image
    shell       Enter a shell
    admin       Enter a shell with sudo
    claude      Start a claude session
    codex       Start a codex session
EOF
}

# Remove AgentBox images and cached data
cleanup_all() {
    log_warning "Removing AgentBox images and cached data..."

    # Remove AgentBox image
    if docker image inspect "$IMAGE_NAME" &> /dev/null; then
        log_info "Removing AgentBox image"
        docker rmi "$IMAGE_NAME" &> /dev/null || true
    fi

    if [[ -d ".agentbox" ]]; then
      log_warning "This will also remove cached data."
      echo -n "Remove cached data? (y/N): "
      read -r response
      if [[ "$response" =~ ^[Yy]$ ]]; then
          rm -rf .agentbox
          log_success "Cached data removed"
      else
          log_info "Cached data preserved"
      fi
    fi

    log_success "Cleanup complete"
}

# Main execution
main() {
    if [[ $# -eq 0 ]]; then
      echo "Need command"
      show_help
      exit 1
    fi

    local mode="$1"
    shift
    local cmd_args=("$@")

    case "$mode" in
        shell) ;;
        admin) ;;
        claude) ;;
        codex) ;;
        clean) ;;
        build) ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown command"
            show_help
            exit 1
            ;;
    esac

    # Check Docker
    check_docker

    # Handle special commands
    if [[ "$mode" == "clean" ]]; then
        cleanup_all
        exit 0
    fi

    # Get container name for current project
    local container_name=$(get_container_name)

    # Check if rebuild is needed or forced
    if [[ "$mode" == "build" ]] || needs_rebuild; then
        if [[ "$mode" == "build" ]]; then
            log_info "Forcing image rebuild..."
        else
            log_info "Dockerfile or entrypoint changed, rebuilding automatically..."
        fi

        if ! build_image; then
            log_error "Build failed!"
            exit 1
        fi

        if [[ "$mode" == "build" ]]; then
          exit 0
        fi
    fi

    # Run or attach to container
    run_container "$container_name" "$mode" "${cmd_args[@]}"
}

# Run main function
main "$@"
